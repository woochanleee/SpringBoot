# 민기 코드 이해하기

## [소스 코드](https://github.com/bookbook-javaproject/Frame-Backend-Core)

## Controller

> `@Controller` - Spring MVC Controller

- 전통적인 **Spring MVC**의 컨트롤러인 `@Controller`는 주로 **View**를 반환하기 위해 사용한다.
- **Spring MVC Container**는 **Client의** 요청으로부터 **View**를 반환한다.

![](./spring_container.png)

> `@RequestBody`

- 클라이언트에서 서버로 필요한 데이터를 전송하기 위해서 JSON이라는 데이터를 요청 본문에 담아서 서버로 보내면, 서버에서는 `@RequestBody` 어노테이션을 사용하여 HTTP 요청 본문에 담긴 값들을 자바 객체로 변환 시켜, 객체에 저장시킨다.

> `@ResponseBody`

- 서버에서 클라이언트로 응답 데이터를 전송하기 위해서 `@ResponseBody`를 사용하여 자바 객체를 HTTP 응답 본문의 객체로 변환하여 클라이언트로 전송시키는 역할을 한다.

> `@RestController` - Spring Restful Controller

- `@RestController`는 Spring MVC Controller에 `@ResponseBody`가 추가된 것이다. 당연하게도 RestController의 주용도는 JSON 형태로 객체 데이터를 반환하는 것이다.

> `@RequestMapping`

- 어노테이션에 명시한 주소로 요청시 매핑된다.
- ex) `@RequestMapping(value = "/user", method = RequestMethod.POST)`
- ex) `@RequestMapping('/user')`
- 클래스에 어노테이션을 사용해도 정상 작동한다.

> `@GetMapping`

- HTTP 요청시 GET으로 왔을때 매핑해준다.
- +) 어노테이션에 파라미터가 1개만 넘어오면 value에 매핑 된다.

> `@RequestParam`

- HTTP 요청시 <b>쿼리 스트링(파라미터)</b>로 오는 값을 사용할수 있게 된다.
- 이 어노테이션을 사용했을땐 해당 파라미터로 넘오오는 값이 있어야 된다.
- 아닐 경우 4xx 에러 발생. 이를 해결하기 위해 아래와 같이 추가 옵션을 선택할 수 있다.
- ex) `@RequestParam(value = "email", required = false, defaultValue = "test@test.com")`

```java
@GetMapping("/relation")
@ResponseStatus(value = HttpStatus.OK)
public GetRelationResponse getRelation(@RequestParam("email") String email) {
    return userService.getRelation(email);
}
```

> `@PostMapping`

- HTTP 요청시 POST로 왔을때 매핑해준다.

> `@Valid`

- 유효성 검사
- `@RequestBody`로 넘어오는 객체를 검증할때 사용하곤 함

```java
@PostMapping("/auth")
@ResponseStatus(value = HttpStatus.OK)
public LoginResponse login(@RequestBody @Valid LoginRequest request) {
    return userService.login(request);
}
```

> `@RequiredArgsConstructor`

- 이 어노테이션은 **초기화 되지않은 final 필드**나, **@NonNull** 이 붙은 필드에 대해 생성자를 생성해 준다.
- 주로 **의존성 주입**(Dependency Injection) 편의성을 위해 사용하곤 한다.
- **스프링 의존성 주입의 특징** 중 한가지를 이용하는데 다음과 같다.
- 어떠한 빈(Bean)에 생성자가 **오직 하나**만 있고, 생성자의 파라미터 타입이 **빈으로 등록 가능한 존재**라면 이 빈은 @Autowired 어노테이션 없이도 의존성 주입이 가능하다.

> `@ResponseStatus`

- 응답 코드를 설정해준다.
- ex) `@ResponseStatus(value = HttpStatus.OK)` - 200
- ex) `@ResponseStatus(value = HttpStatus.CREATED)` - 201
- 용성이가 알려준건데 200은 디폴트라 없어도 된다고 한다! 개쩔어
- 매핑된 컨트롤러 메서드가 정상 종료되면 응답코드를 넣어준다. 메서드 실행 도중 예외가 나면 ResponseStatus 어노테이션 기능은 작동하지 않는다.

## Domain > Entity

> `@Getter` - Lombok

- 접근자 자동 생성
- `xx`라는 필드를 선언하면 자동으로 `getXx()`(boolean 타입인 경우, `isXx()`) 메서드를 생성해 줌
- 이 기능을 적용하고 싶은 클래스에 어노테이션을 선언해주면 됨

> `@Setter` - Lombok

- 설정자 자동 생성
- `xx`라는 필드를 선언하면 자동으로 `setXx()` 메서드를 생성해 줌
- 이 기능을 적용하고 싶은 클래스에 어노테이션을 선언해주면 됨

## References

- [[Spring] @Controller와 @RestController 차이](https://mangkyu.tistory.com/49)
- [@ReqeustBody와 @ResponseBody 언제 사용할까?](https://medium.com/webeveloper/reqeustbody%EC%99%80-responsebody-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C-2efcab364edb)
- [[spring] @RequestMapping](https://joont92.github.io/spring/@RequestMapping/)
- [@RequiredArgsConstructor 를 이용한 의존성 주입(Dependency Injection)](https://medium.com/webeveloper/requiredargsconstructor-%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-dependency-injection-4f1b0ac33561)
- [@Valid 를 이용해 @RequestBody 객체 검증하기](https://jyami.tistory.com/55)
- [[자바] 자주 사용되는 Lombok 어노테이션](https://www.daleseo.com/lombok-popular-annotations/)
